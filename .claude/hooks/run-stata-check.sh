#!/bin/bash
#
# run-stata-check.sh - Run Stata syntax check on .ado file
#
# This hook requires Stata to be installed and available as 'stata-mp'.
# It compiles the .ado file to check for syntax errors.
#
# Usage: run-stata-check.sh FILE.ado
#
# Environment:
#   STATA_EXEC    - Path to Stata executable (default: stata-mp)
#   STATA_TIMEOUT - Timeout in seconds (default: 60)
#
# Exit codes:
#   0 - Syntax valid
#   1 - Syntax errors found
#   2 - Stata not available or timeout
#   3 - Configuration error
#

# Source common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/common.sh" || {
    echo "[ERROR] Failed to source common.sh" >&2
    exit 3
}

# Setup cleanup trap immediately
setup_cleanup_trap

# Configuration
STATA_EXEC="${STATA_EXEC:-stata-mp}"
STATA_TIMEOUT="${STATA_TIMEOUT:-60}"

# Validate arguments
if [[ $# -lt 1 ]]; then
    echo "Usage: $0 FILE.ado"
    exit 3
fi

FILE="$1"
BASENAME=$(basename "$FILE" .ado)
DIRPATH=$(cd "$(dirname "$FILE")" && pwd)
FULLPATH="$DIRPATH/$(basename "$FILE")"

# Validate file exists
if [[ ! -f "$FILE" ]]; then
    error "File not found: $FILE"
    exit 3
fi

# Check if Stata is available
if ! command -v "$STATA_EXEC" &>/dev/null; then
    warn "Stata not found ($STATA_EXEC). Skipping syntax check."
    info "Set STATA_EXEC environment variable to Stata path."
    exit 2
fi

# Check if timeout command is available
TIMEOUT_CMD=""
if command -v timeout &>/dev/null; then
    TIMEOUT_CMD="timeout $STATA_TIMEOUT"
elif command -v gtimeout &>/dev/null; then
    TIMEOUT_CMD="gtimeout $STATA_TIMEOUT"  # macOS with coreutils
else
    debug "timeout command not available, running without timeout"
fi

info "Running Stata syntax check on: $FILE"
echo "================================"

# Create temporary files with cleanup registration
TEMP_DO=$(make_temp_file "stata_check") || exit 3
TEMP_LOG=$(make_temp_file "stata_log") || exit 3

# Generate the do file
# Note: Using 'include' instead of 'run' to properly parse .ado files
cat > "$TEMP_DO" << EOF
* Syntax check for $FILE
* Generated by run-stata-check.sh

version 18.0
set more off
set varabbrev off

* Attempt to include the program definition to check syntax
capture noisily include "$FULLPATH"
if _rc != 0 {
    display as error "Syntax error in $FILE"
    display as error "Return code: " _rc
    exit _rc
}

* Try to verify the program was defined
capture noisily program list $BASENAME
if _rc == 0 {
    display as result "Program $BASENAME compiled successfully"
}
else {
    * Program might not be named same as file, that's OK
    display as result "File parsed without errors"
}

display as result "STATA_CHECK_PASSED"
exit 0
EOF

debug "Do file contents:"
debug "$(cat "$TEMP_DO")"

# Run Stata in batch mode with optional timeout
STATA_RC=0
if [[ -n "$TIMEOUT_CMD" ]]; then
    $TIMEOUT_CMD "$STATA_EXEC" -b do "$TEMP_DO" > "$TEMP_LOG" 2>&1 || STATA_RC=$?
else
    "$STATA_EXEC" -b do "$TEMP_DO" > "$TEMP_LOG" 2>&1 || STATA_RC=$?
fi

# Check for timeout (exit code 124 from timeout command)
if [[ $STATA_RC -eq 124 ]]; then
    echo ""
    echo "================================"
    error "TIMEOUT: Stata did not complete within ${STATA_TIMEOUT}s"
    exit 2
fi

# Display log contents for debugging
if [[ "$DEBUG" == "1" ]]; then
    debug "Stata log contents:"
    cat "$TEMP_LOG"
fi

# Check for various error indicators in log
ERROR_FOUND=0
ERROR_DETAILS=""

# Check for Stata return code pattern: r(NNN); (with optional whitespace)
if grep -qE "^[[:space:]]*r\([0-9]+\);[[:space:]]*$" "$TEMP_LOG" 2>/dev/null; then
    ERROR_CODE=$(grep -oE "r\([0-9]+\);" "$TEMP_LOG" | head -1 | grep -oE "[0-9]+")
    echo ""
    echo "================================"
    error "Stata returned error code: $ERROR_CODE"
    ERROR_FOUND=1
fi

# Check for various Stata error patterns (case-insensitive where appropriate)
# These patterns cover common Stata error messages
ERROR_PATTERNS=(
    "syntax error"
    "invalid syntax"
    "unrecognized command"
    "invalid command"
    "type mismatch"
    "variable .* not found"
    "file .* not found"
    "option .* not allowed"
    "too few variables"
    "too many variables"
    "varlist required"
    "parse error"
    "undefined"
    "unknown function"
)

for pattern in "${ERROR_PATTERNS[@]}"; do
    if grep -qi "$pattern" "$TEMP_LOG" 2>/dev/null; then
        ERROR_FOUND=1
        ERROR_DETAILS="$ERROR_DETAILS (matched: $pattern)"
        break
    fi
done

# Check for explicit "error" at start of line (Stata error output)
if grep -qE "^[[:space:]]*(error|Error)" "$TEMP_LOG" 2>/dev/null; then
    ERROR_FOUND=1
fi

if [[ $ERROR_FOUND -eq 1 ]]; then
    echo ""
    echo "--- Relevant log output ---"
    grep -iE "(error|invalid|undefined|unrecognized|syntax|not found|mismatch|^[[:space:]]*r\([0-9]+\))" "$TEMP_LOG" 2>/dev/null | head -20
    exit 1
fi

# Check for success marker
if grep -q "STATA_CHECK_PASSED" "$TEMP_LOG" 2>/dev/null; then
    echo ""
    echo "================================"
    pass "Stata syntax check successful"
    exit 0
fi

# Ambiguous result
echo ""
echo "================================"
warn "Could not verify syntax check result"
info "Check log for details: $TEMP_LOG"
# Keep log file for debugging - copy to persistent location
LOG_BACKUP="/tmp/stata_check_ambiguous_$(date +%Y%m%d_%H%M%S).log"
cp "$TEMP_LOG" "$LOG_BACKUP" 2>/dev/null && info "Log saved to: $LOG_BACKUP"
exit 2
