#!/usr/bin/env python3
"""
Excel file analyzer for Stata-generated tables.

Analyzes Excel files generated by Stata commands (table1_tc, regtab, stratetab)
and produces a comprehensive text report on formatting, borders, fonts, merges,
and structure. Designed to help Claude "see" and verify Excel output.

Usage:
    python excel_analyzer.py file.xlsx
    python excel_analyzer.py file.xlsx --sheet "Table 1"
    python excel_analyzer.py file.xlsx --rows 10 --verbose

Requirements:
    openpyxl>=3.1.0

Author: Timothy P. Copeland
"""

import argparse
import re
import sys
from collections import Counter, defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

try:
    from openpyxl import load_workbook
    from openpyxl.cell import Cell, MergedCell
    from openpyxl.utils import get_column_letter
    from openpyxl.worksheet.worksheet import Worksheet
except ImportError:
    print("Error: openpyxl is required. Install with: pip install openpyxl", file=sys.stderr)
    sys.exit(1)


# =============================================================================
# Data Classes
# =============================================================================

@dataclass
class MergedRegion:
    """Represents a merged cell region."""
    range_string: str
    start_row: int
    end_row: int
    start_col: int
    end_col: int
    value: Any = None

    @property
    def is_horizontal(self) -> bool:
        return self.start_row == self.end_row and self.start_col != self.end_col

    @property
    def is_vertical(self) -> bool:
        return self.start_col == self.end_col and self.start_row != self.end_row

    @property
    def is_block(self) -> bool:
        return self.start_row != self.end_row and self.start_col != self.end_col

    @property
    def span_description(self) -> str:
        if self.is_horizontal:
            return f"horizontal ({self.end_col - self.start_col + 1} cols)"
        elif self.is_vertical:
            return f"vertical ({self.end_row - self.start_row + 1} rows)"
        else:
            return f"block ({self.end_row - self.start_row + 1}x{self.end_col - self.start_col + 1})"


@dataclass
class BorderInfo:
    """Information about borders in a cell."""
    top: Optional[str] = None
    bottom: Optional[str] = None
    left: Optional[str] = None
    right: Optional[str] = None

    def has_any(self) -> bool:
        return any([self.top, self.bottom, self.left, self.right])

    def sides_with_borders(self) -> list[str]:
        sides = []
        if self.top: sides.append(f"top:{self.top}")
        if self.bottom: sides.append(f"bottom:{self.bottom}")
        if self.left: sides.append(f"left:{self.left}")
        if self.right: sides.append(f"right:{self.right}")
        return sides


@dataclass
class FontInfo:
    """Information about font in a cell."""
    name: Optional[str] = None
    size: Optional[float] = None
    bold: bool = False
    italic: bool = False
    color: Optional[str] = None


@dataclass
class AlignmentInfo:
    """Information about alignment in a cell."""
    horizontal: Optional[str] = None
    vertical: Optional[str] = None
    wrap_text: bool = False


@dataclass
class AnalysisResult:
    """Container for all analysis results."""
    # Structure
    total_rows: int = 0
    total_cols: int = 0
    used_range: str = ""
    merged_regions: list = field(default_factory=list)
    empty_rows: list = field(default_factory=list)
    empty_cols: list = field(default_factory=list)

    # Borders
    border_styles: Counter = field(default_factory=Counter)
    cells_with_borders: dict = field(default_factory=dict)
    border_patterns: list = field(default_factory=list)

    # Fonts
    font_families: Counter = field(default_factory=Counter)
    font_sizes: Counter = field(default_factory=Counter)
    bold_cells: list = field(default_factory=list)
    italic_cells: list = field(default_factory=list)
    font_consistent: bool = True

    # Alignment
    horizontal_alignments: Counter = field(default_factory=Counter)
    vertical_alignments: Counter = field(default_factory=Counter)
    wrap_text_cells: list = field(default_factory=list)

    # Dimensions
    column_widths: dict = field(default_factory=dict)
    row_heights: dict = field(default_factory=dict)
    non_default_heights: dict = field(default_factory=dict)

    # Content
    content_preview: list = field(default_factory=list)
    value_types: Counter = field(default_factory=Counter)
    detected_patterns: list = field(default_factory=list)

    # Table type
    likely_table_type: str = "unknown"
    table_type_confidence: str = "LOW"
    table_type_evidence: list = field(default_factory=list)


# =============================================================================
# Analyzers
# =============================================================================

class StructureAnalyzer:
    """Analyze table structure: dimensions, merges, empty regions."""

    def analyze(self, sheet: Worksheet) -> dict:
        result = {
            'total_rows': sheet.max_row or 0,
            'total_cols': sheet.max_column or 0,
            'used_range': sheet.dimensions or "Empty",
            'merged_regions': [],
            'empty_rows': [],
            'empty_cols': []
        }

        # Analyze merged cells
        for merged_range in sheet.merged_cells.ranges:
            bounds = merged_range.bounds  # (min_col, min_row, max_col, max_row)
            top_left = sheet.cell(row=bounds[1], column=bounds[0])
            value = top_left.value

            region = MergedRegion(
                range_string=str(merged_range),
                start_row=bounds[1],
                end_row=bounds[3],
                start_col=bounds[0],
                end_col=bounds[2],
                value=value
            )
            result['merged_regions'].append(region)

        # Sort by position
        result['merged_regions'].sort(key=lambda r: (r.start_row, r.start_col))

        # Find empty rows
        if result['total_rows'] > 0:
            for row_num in range(1, result['total_rows'] + 1):
                row_empty = True
                for col_num in range(1, result['total_cols'] + 1):
                    cell = sheet.cell(row=row_num, column=col_num)
                    if cell.value is not None and str(cell.value).strip():
                        row_empty = False
                        break
                if row_empty:
                    result['empty_rows'].append(row_num)

        # Find empty columns
        if result['total_cols'] > 0:
            for col_num in range(1, result['total_cols'] + 1):
                col_empty = True
                for row_num in range(1, result['total_rows'] + 1):
                    cell = sheet.cell(row=row_num, column=col_num)
                    if cell.value is not None and str(cell.value).strip():
                        col_empty = False
                        break
                if col_empty:
                    result['empty_cols'].append(get_column_letter(col_num))

        return result


class BorderAnalyzer:
    """Analyze border styles and patterns."""

    def analyze(self, sheet: Worksheet) -> dict:
        result = {
            'border_styles': Counter(),
            'cells_with_borders': defaultdict(list),
            'border_patterns': []
        }

        top_borders = []
        bottom_borders = []
        left_borders = []
        right_borders = []

        for row_num in range(1, (sheet.max_row or 0) + 1):
            for col_num in range(1, (sheet.max_column or 0) + 1):
                cell = sheet.cell(row=row_num, column=col_num)
                cell_ref = f"{get_column_letter(col_num)}{row_num}"

                if isinstance(cell, MergedCell):
                    continue

                border = cell.border
                if border:
                    if border.top and border.top.style:
                        result['border_styles'][border.top.style] += 1
                        top_borders.append(cell_ref)
                    if border.bottom and border.bottom.style:
                        result['border_styles'][border.bottom.style] += 1
                        bottom_borders.append(cell_ref)
                    if border.left and border.left.style:
                        result['border_styles'][border.left.style] += 1
                        left_borders.append(cell_ref)
                    if border.right and border.right.style:
                        result['border_styles'][border.right.style] += 1
                        right_borders.append(cell_ref)

        result['cells_with_borders']['top'] = top_borders
        result['cells_with_borders']['bottom'] = bottom_borders
        result['cells_with_borders']['left'] = left_borders
        result['cells_with_borders']['right'] = right_borders

        # Detect patterns
        if top_borders:
            rows_with_top = set(re.search(r'\d+', ref).group() for ref in top_borders)
            result['border_patterns'].append(f"Top borders in rows: {sorted(rows_with_top, key=int)}")

        if bottom_borders:
            rows_with_bottom = set(re.search(r'\d+', ref).group() for ref in bottom_borders)
            result['border_patterns'].append(f"Bottom borders in rows: {sorted(rows_with_bottom, key=int)}")

        return result


class FontAnalyzer:
    """Analyze font usage patterns."""

    def analyze(self, sheet: Worksheet) -> dict:
        result = {
            'font_families': Counter(),
            'font_sizes': Counter(),
            'bold_cells': [],
            'italic_cells': [],
            'font_consistent': True
        }

        fonts_seen = set()

        for row_num in range(1, (sheet.max_row or 0) + 1):
            for col_num in range(1, (sheet.max_column or 0) + 1):
                cell = sheet.cell(row=row_num, column=col_num)
                cell_ref = f"{get_column_letter(col_num)}{row_num}"

                if isinstance(cell, MergedCell):
                    continue

                font = cell.font
                if font:
                    font_name = font.name or "Default"
                    font_size = font.size or 11

                    result['font_families'][font_name] += 1
                    result['font_sizes'][font_size] += 1
                    fonts_seen.add((font_name, font_size))

                    if font.bold:
                        result['bold_cells'].append(cell_ref)
                    if font.italic:
                        result['italic_cells'].append(cell_ref)

        # Check consistency
        if len(fonts_seen) > 1:
            result['font_consistent'] = False

        return result


class AlignmentAnalyzer:
    """Analyze text alignment settings."""

    def analyze(self, sheet: Worksheet) -> dict:
        result = {
            'horizontal_alignments': Counter(),
            'vertical_alignments': Counter(),
            'wrap_text_cells': []
        }

        for row_num in range(1, (sheet.max_row or 0) + 1):
            for col_num in range(1, (sheet.max_column or 0) + 1):
                cell = sheet.cell(row=row_num, column=col_num)
                cell_ref = f"{get_column_letter(col_num)}{row_num}"

                if isinstance(cell, MergedCell):
                    continue

                alignment = cell.alignment
                if alignment:
                    h_align = alignment.horizontal or "general"
                    v_align = alignment.vertical or "bottom"

                    result['horizontal_alignments'][h_align] += 1
                    result['vertical_alignments'][v_align] += 1

                    if alignment.wrap_text:
                        result['wrap_text_cells'].append(cell_ref)

        return result


class DimensionAnalyzer:
    """Analyze row heights and column widths."""

    DEFAULT_ROW_HEIGHT = 15.0
    DEFAULT_COL_WIDTH = 8.43

    def analyze(self, sheet: Worksheet) -> dict:
        result = {
            'column_widths': {},
            'row_heights': {},
            'non_default_heights': {}
        }

        # Column widths
        for col_num in range(1, (sheet.max_column or 0) + 1):
            col_letter = get_column_letter(col_num)
            col_dim = sheet.column_dimensions.get(col_letter)
            if col_dim and col_dim.width:
                result['column_widths'][col_letter] = round(col_dim.width, 2)
            else:
                result['column_widths'][col_letter] = self.DEFAULT_COL_WIDTH

        # Row heights
        for row_num in range(1, (sheet.max_row or 0) + 1):
            row_dim = sheet.row_dimensions.get(row_num)
            if row_dim and row_dim.height:
                result['row_heights'][row_num] = row_dim.height
                if abs(row_dim.height - self.DEFAULT_ROW_HEIGHT) > 0.5:
                    result['non_default_heights'][row_num] = row_dim.height
            else:
                result['row_heights'][row_num] = self.DEFAULT_ROW_HEIGHT

        return result


class ContentAnalyzer:
    """Analyze cell content and value types."""

    def analyze(self, sheet: Worksheet, preview_rows: int = 10) -> dict:
        result = {
            'content_preview': [],
            'value_types': Counter(),
            'detected_patterns': []
        }

        # Content preview
        for row_num in range(1, min(preview_rows + 1, (sheet.max_row or 0) + 1)):
            row_data = []
            for col_num in range(1, (sheet.max_column or 0) + 1):
                cell = sheet.cell(row=row_num, column=col_num)
                value = cell.value

                if value is None:
                    row_data.append("")
                else:
                    # Truncate long values
                    str_val = str(value)
                    if len(str_val) > 30:
                        str_val = str_val[:27] + "..."
                    row_data.append(str_val)

            result['content_preview'].append(row_data)

        # Analyze value types and patterns
        all_values = []
        for row_num in range(1, (sheet.max_row or 0) + 1):
            for col_num in range(1, (sheet.max_column or 0) + 1):
                cell = sheet.cell(row=row_num, column=col_num)
                value = cell.value

                if value is None:
                    result['value_types']['empty'] += 1
                elif isinstance(value, (int, float)):
                    result['value_types']['numeric'] += 1
                elif isinstance(value, str):
                    result['value_types']['text'] += 1
                    all_values.append(value)
                else:
                    result['value_types']['other'] += 1

        # Detect patterns
        patterns_found = set()

        for val in all_values:
            # N= pattern (table1_tc)
            if re.match(r'^N\s*=\s*\d', val):
                patterns_found.add("N= (sample size)")

            # P-value pattern
            if re.match(r'^0\.\d{2,4}$', val) or val == '<0.001':
                patterns_found.add("p-values")

            # CI pattern (lower, upper) or (lower-upper)
            if re.match(r'^\([\d\.-]+[,;]\s*[\d\.-]+\)$', val):
                patterns_found.add("confidence intervals (X, Y)")

            # CI pattern: value (lower, upper)
            if re.match(r'^[\d\.-]+\s*\([\d\.-]+[,;\-]\s*[\d\.-]+\)$', val):
                patterns_found.add("point estimate with CI")

            # Percentage pattern
            if re.search(r'\d+\.?\d*\s*%', val) or re.match(r'^\d+\s*\(\d+\.?\d*%?\)$', val):
                patterns_found.add("percentages")

            # Reference category
            if val.lower() in ('reference', 'ref', 'ref.'):
                patterns_found.add("reference categories")

            # Rate per 1000 pattern
            if re.match(r'^\d+\.?\d*\s*\([\d\.]+-[\d\.]+\)$', val):
                patterns_found.add("rates with CI")

        result['detected_patterns'] = list(patterns_found)

        return result


class VisualMapper:
    """Generate ASCII visualization of table structure."""

    def generate_map(self, sheet: Worksheet, max_rows: int = 15, max_cols: int = 8) -> str:
        """Generate an ASCII map of the table structure."""
        lines = []

        total_rows = min(sheet.max_row or 0, max_rows)
        total_cols = min(sheet.max_column or 0, max_cols)

        if total_rows == 0 or total_cols == 0:
            return "  (Empty sheet)"

        # Get merged cell ranges for quick lookup
        merged_cells = {}
        for merged_range in sheet.merged_cells.ranges:
            bounds = merged_range.bounds
            for r in range(bounds[1], bounds[3] + 1):
                for c in range(bounds[0], bounds[2] + 1):
                    merged_cells[(r, c)] = {
                        'start': (bounds[1], bounds[0]),
                        'end': (bounds[3], bounds[2]),
                        'is_start': (r == bounds[1] and c == bounds[0])
                    }

        # Calculate column widths based on content
        col_widths = []
        for col_num in range(1, total_cols + 1):
            max_width = 8  # minimum
            for row_num in range(1, total_rows + 1):
                cell = sheet.cell(row=row_num, column=col_num)
                if cell.value:
                    val_str = str(cell.value)[:20]
                    max_width = max(max_width, len(val_str) + 2)
            col_widths.append(min(max_width, 20))

        # Generate map
        def make_separator(char='-', cols=col_widths):
            return '+' + '+'.join(char * w for w in cols) + '+'

        lines.append(make_separator('='))

        for row_num in range(1, total_rows + 1):
            row_cells = []
            for col_num in range(1, total_cols + 1):
                width = col_widths[col_num - 1]
                cell = sheet.cell(row=row_num, column=col_num)

                merge_info = merged_cells.get((row_num, col_num))

                if merge_info and not merge_info['is_start']:
                    # Part of merged cell but not the start
                    row_cells.append(' ' * width)
                else:
                    value = cell.value if cell.value else ""
                    val_str = str(value)[:width-2]

                    if merge_info:
                        val_str = val_str + " [M]"

                    row_cells.append(f" {val_str:<{width-2}} ")

            line = '|' + '|'.join(row_cells) + '|'
            lines.append(line)

            # Add separator after each row
            if row_num <= 3:
                lines.append(make_separator('='))
            else:
                lines.append(make_separator('-'))

        # Add note if truncated
        if (sheet.max_row or 0) > max_rows or (sheet.max_column or 0) > max_cols:
            lines.append(f"  ... (showing {total_rows} of {sheet.max_row} rows, {total_cols} of {sheet.max_column} cols)")

        lines.append("")
        lines.append("Legend: [M] = merged cell")

        return '\n'.join(lines)


class TableTypeDetector:
    """Detect which Stata command likely generated the Excel file."""

    def detect(self, sheet: Worksheet, analysis: AnalysisResult) -> dict:
        result = {
            'likely_type': 'unknown',
            'confidence': 'LOW',
            'evidence': []
        }

        scores = {
            'table1_tc': 0,
            'regtab': 0,
            'stratetab': 0
        }

        evidence = {
            'table1_tc': [],
            'regtab': [],
            'stratetab': []
        }

        # Check for merged title row
        title_merged = False
        for region in analysis.merged_regions:
            if region.start_row == 1 and region.start_col == 1:
                title_merged = True
                if region.end_col >= 3:
                    scores['table1_tc'] += 1
                    scores['regtab'] += 1
                    scores['stratetab'] += 1
                    evidence['table1_tc'].append("Title row merged across columns")
                    evidence['regtab'].append("Title row merged across columns")
                    evidence['stratetab'].append("Title row merged across columns")

        # Check content patterns
        patterns = set(analysis.detected_patterns)

        if "N= (sample size)" in patterns:
            scores['table1_tc'] += 3
            evidence['table1_tc'].append("N= pattern detected (sample size)")

        if "reference categories" in patterns:
            scores['regtab'] += 3
            evidence['regtab'].append("Reference categories detected")

        if "percentages" in patterns:
            scores['table1_tc'] += 2
            evidence['table1_tc'].append("Percentage patterns in data")

        if "p-values" in patterns:
            scores['table1_tc'] += 1
            scores['regtab'] += 1
            evidence['table1_tc'].append("P-value column detected")
            evidence['regtab'].append("P-value column detected")

        if "confidence intervals (X, Y)" in patterns:
            scores['regtab'] += 2
            evidence['regtab'].append("CI format (X, Y) detected")

        if "rates with CI" in patterns:
            scores['stratetab'] += 3
            evidence['stratetab'].append("Rate (CI) format detected")

        # Check for 3-column groups (regtab and stratetab)
        num_cols = analysis.total_cols
        if num_cols > 3 and (num_cols - 1) % 3 == 0:  # First col is labels
            scores['regtab'] += 2
            scores['stratetab'] += 2
            evidence['regtab'].append(f"Column count ({num_cols}) suggests 3-column model groups")
            evidence['stratetab'].append(f"Column count ({num_cols}) suggests 3-column outcome groups")

        # Check merged cell patterns
        row2_merges = [r for r in analysis.merged_regions if r.start_row == 2]
        for merge in row2_merges:
            if merge.end_col - merge.start_col == 2:  # 3-column merge
                scores['regtab'] += 2
                scores['stratetab'] += 2
                evidence['regtab'].append("Row 2 has 3-column merged headers (model groups)")
                evidence['stratetab'].append("Row 2 has 3-column merged headers (outcome groups)")
                break

        # Check for vertical merges in header (table1_tc pattern)
        vertical_header_merges = [r for r in analysis.merged_regions
                                  if r.is_vertical and r.start_row <= 3]
        if len(vertical_header_merges) >= 2:
            scores['table1_tc'] += 2
            evidence['table1_tc'].append("Vertical merges in header rows (rows 2-3)")

        # Check font (Arial 10pt is used by all)
        if 'Arial' in analysis.font_families or 'Calibri' in analysis.font_families:
            pass  # Both common, not discriminating

        # Determine winner
        max_score = max(scores.values())
        if max_score == 0:
            result['likely_type'] = 'unknown'
            result['confidence'] = 'NONE'
            result['evidence'] = ["No distinctive patterns found"]
        else:
            winner = max(scores, key=scores.get)
            result['likely_type'] = winner
            result['evidence'] = evidence[winner]

            # Confidence based on score and margin
            second_score = sorted(scores.values(), reverse=True)[1]
            margin = max_score - second_score

            if max_score >= 5 and margin >= 2:
                result['confidence'] = 'HIGH'
            elif max_score >= 3:
                result['confidence'] = 'MEDIUM'
            else:
                result['confidence'] = 'LOW'

        return result


# =============================================================================
# Main Analyzer
# =============================================================================

class ExcelAnalyzer:
    """Main class that coordinates all analysis components."""

    def __init__(self, filepath: str):
        self.filepath = Path(filepath)
        self.workbook = None
        self.sheet = None

    def load(self, sheet_name: Optional[str] = None) -> bool:
        """Load the Excel file."""
        try:
            self.workbook = load_workbook(str(self.filepath), data_only=True)

            if sheet_name:
                if sheet_name in self.workbook.sheetnames:
                    self.sheet = self.workbook[sheet_name]
                else:
                    print(f"Error: Sheet '{sheet_name}' not found.", file=sys.stderr)
                    print(f"Available sheets: {', '.join(self.workbook.sheetnames)}", file=sys.stderr)
                    return False
            else:
                self.sheet = self.workbook.active

            return True
        except Exception as e:
            print(f"Error loading file: {e}", file=sys.stderr)
            return False

    def analyze(self, preview_rows: int = 10) -> AnalysisResult:
        """Run all analyzers and return combined result."""
        result = AnalysisResult()

        if not self.sheet:
            return result

        # Structure analysis
        structure = StructureAnalyzer().analyze(self.sheet)
        result.total_rows = structure['total_rows']
        result.total_cols = structure['total_cols']
        result.used_range = structure['used_range']
        result.merged_regions = structure['merged_regions']
        result.empty_rows = structure['empty_rows']
        result.empty_cols = structure['empty_cols']

        # Border analysis
        borders = BorderAnalyzer().analyze(self.sheet)
        result.border_styles = borders['border_styles']
        result.cells_with_borders = borders['cells_with_borders']
        result.border_patterns = borders['border_patterns']

        # Font analysis
        fonts = FontAnalyzer().analyze(self.sheet)
        result.font_families = fonts['font_families']
        result.font_sizes = fonts['font_sizes']
        result.bold_cells = fonts['bold_cells']
        result.italic_cells = fonts['italic_cells']
        result.font_consistent = fonts['font_consistent']

        # Alignment analysis
        alignments = AlignmentAnalyzer().analyze(self.sheet)
        result.horizontal_alignments = alignments['horizontal_alignments']
        result.vertical_alignments = alignments['vertical_alignments']
        result.wrap_text_cells = alignments['wrap_text_cells']

        # Dimension analysis
        dimensions = DimensionAnalyzer().analyze(self.sheet)
        result.column_widths = dimensions['column_widths']
        result.row_heights = dimensions['row_heights']
        result.non_default_heights = dimensions['non_default_heights']

        # Content analysis
        content = ContentAnalyzer().analyze(self.sheet, preview_rows)
        result.content_preview = content['content_preview']
        result.value_types = content['value_types']
        result.detected_patterns = content['detected_patterns']

        # Table type detection
        table_type = TableTypeDetector().detect(self.sheet, result)
        result.likely_table_type = table_type['likely_type']
        result.table_type_confidence = table_type['confidence']
        result.table_type_evidence = table_type['evidence']

        return result


# =============================================================================
# Report Formatter
# =============================================================================

class ReportFormatter:
    """Format analysis results into readable text report."""

    def __init__(self, filepath: str, sheet_name: str, result: AnalysisResult):
        self.filepath = filepath
        self.sheet_name = sheet_name
        self.result = result

    def format_header(self) -> str:
        lines = [
            "=" * 78,
            "EXCEL FILE ANALYSIS REPORT",
            "=" * 78,
            f"File: {self.filepath}",
            f"Sheet: {self.sheet_name}",
            f"Analyzed: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            ""
        ]
        return '\n'.join(lines)

    def format_summary(self) -> str:
        r = self.result
        lines = [
            "QUICK SUMMARY:",
            f"- Dimensions: {r.total_rows} rows x {r.total_cols} columns ({r.used_range})",
            f"- Merged cells: {len(r.merged_regions)} regions",
        ]

        # Font summary
        top_font = r.font_families.most_common(1)
        top_size = r.font_sizes.most_common(1)
        if top_font and top_size:
            font_str = f"{top_font[0][0]} {top_size[0][0]}pt"
            consistency = "consistent" if r.font_consistent else "mixed"
            lines.append(f"- Font: {font_str} ({consistency})")

        # Border summary
        if r.border_styles:
            border_str = ', '.join(f"{style}" for style, _ in r.border_styles.most_common(2))
            lines.append(f"- Borders: {border_str}")
        else:
            lines.append("- Borders: None detected")

        # Table type
        lines.append(f"- Likely table type: {r.likely_table_type} ({r.table_type_confidence} confidence)")
        lines.append("")

        return '\n'.join(lines)

    def format_structure(self) -> str:
        r = self.result
        lines = [
            "=" * 78,
            "A. STRUCTURE ANALYSIS",
            "=" * 78,
            f"Total rows with content: {r.total_rows}",
            f"Total columns with content: {r.total_cols}",
            f"Used range: {r.used_range}",
            ""
        ]

        if r.merged_regions:
            lines.append("Merged Cell Regions:")
            for i, region in enumerate(r.merged_regions[:15], 1):
                value_preview = ""
                if region.value:
                    val_str = str(region.value)[:40]
                    if len(str(region.value)) > 40:
                        val_str += "..."
                    value_preview = f' "{val_str}"'
                lines.append(f"  {i}. {region.range_string} - {region.span_description}{value_preview}")
            if len(r.merged_regions) > 15:
                lines.append(f"  ... and {len(r.merged_regions) - 15} more")
        else:
            lines.append("Merged Cell Regions: None")

        lines.append("")

        if r.empty_rows:
            lines.append(f"Empty Rows: {r.empty_rows[:10]}{'...' if len(r.empty_rows) > 10 else ''}")
        else:
            lines.append("Empty Rows: None")

        if r.empty_cols:
            lines.append(f"Empty Columns: {r.empty_cols[:10]}{'...' if len(r.empty_cols) > 10 else ''}")
        else:
            lines.append("Empty Columns: None")

        lines.append("")
        return '\n'.join(lines)

    def format_borders(self) -> str:
        r = self.result
        lines = [
            "=" * 78,
            "B. BORDER ANALYSIS",
            "=" * 78,
        ]

        if r.border_styles:
            lines.append("Border Styles Detected:")
            for style, count in r.border_styles.most_common():
                lines.append(f"  {style}: {count} edges")
            lines.append("")

            lines.append("Cells with Borders:")
            for side in ['top', 'bottom', 'left', 'right']:
                cells = r.cells_with_borders.get(side, [])
                if cells:
                    preview = cells[:8]
                    more = f" ... (+{len(cells) - 8} more)" if len(cells) > 8 else ""
                    lines.append(f"  {side.capitalize()}: {', '.join(preview)}{more}")
            lines.append("")

            if r.border_patterns:
                lines.append("Border Patterns:")
                for pattern in r.border_patterns:
                    lines.append(f"  - {pattern}")
        else:
            lines.append("No borders detected in the sheet.")

        lines.append("")
        return '\n'.join(lines)

    def format_fonts(self) -> str:
        r = self.result
        lines = [
            "=" * 78,
            "C. FONT ANALYSIS",
            "=" * 78,
        ]

        lines.append("Font Families Used:")
        for family, count in r.font_families.most_common():
            pct = count / sum(r.font_families.values()) * 100
            lines.append(f"  {family}: {count} cells ({pct:.1f}%)")
        lines.append("")

        lines.append("Font Sizes Used:")
        for size, count in r.font_sizes.most_common():
            pct = count / sum(r.font_sizes.values()) * 100
            lines.append(f"  {size}pt: {count} cells ({pct:.1f}%)")
        lines.append("")

        if r.bold_cells:
            preview = r.bold_cells[:10]
            more = f" ... (+{len(r.bold_cells) - 10} more)" if len(r.bold_cells) > 10 else ""
            lines.append(f"Bold Cells: {', '.join(preview)}{more}")
        else:
            lines.append("Bold Cells: None")

        if r.italic_cells:
            preview = r.italic_cells[:10]
            more = f" ... (+{len(r.italic_cells) - 10} more)" if len(r.italic_cells) > 10 else ""
            lines.append(f"Italic Cells: {', '.join(preview)}{more}")
        else:
            lines.append("Italic Cells: None")

        lines.append("")
        consistency = "CONSISTENT" if r.font_consistent else "INCONSISTENT (multiple fonts/sizes)"
        lines.append(f"Font Consistency: {consistency}")
        lines.append("")

        return '\n'.join(lines)

    def format_alignment(self) -> str:
        r = self.result
        lines = [
            "=" * 78,
            "D. ALIGNMENT ANALYSIS",
            "=" * 78,
        ]

        lines.append("Horizontal Alignment:")
        for align, count in r.horizontal_alignments.most_common():
            pct = count / sum(r.horizontal_alignments.values()) * 100
            lines.append(f"  {align}: {count} cells ({pct:.1f}%)")
        lines.append("")

        lines.append("Vertical Alignment:")
        for align, count in r.vertical_alignments.most_common():
            pct = count / sum(r.vertical_alignments.values()) * 100
            lines.append(f"  {align}: {count} cells ({pct:.1f}%)")
        lines.append("")

        if r.wrap_text_cells:
            preview = r.wrap_text_cells[:10]
            more = f" ... (+{len(r.wrap_text_cells) - 10} more)" if len(r.wrap_text_cells) > 10 else ""
            lines.append(f"Text Wrap Enabled: {', '.join(preview)}{more}")
        else:
            lines.append("Text Wrap Enabled: None")
        lines.append("")

        return '\n'.join(lines)

    def format_dimensions(self) -> str:
        r = self.result
        lines = [
            "=" * 78,
            "E. DIMENSION ANALYSIS",
            "=" * 78,
        ]

        if r.non_default_heights:
            lines.append("Row Heights (non-default only):")
            for row, height in sorted(r.non_default_heights.items())[:10]:
                lines.append(f"  Row {row}: {height} pixels")
            if len(r.non_default_heights) > 10:
                lines.append(f"  ... and {len(r.non_default_heights) - 10} more")
        else:
            lines.append("Row Heights: All default (15px)")
        lines.append("")

        lines.append("Column Widths:")
        widths = list(r.column_widths.items())[:15]
        for col, width in widths:
            lines.append(f"  {col}: {width}")
        if len(r.column_widths) > 15:
            lines.append(f"  ... and {len(r.column_widths) - 15} more columns")
        lines.append("")

        return '\n'.join(lines)

    def format_content(self) -> str:
        r = self.result
        lines = [
            "=" * 78,
            "F. CONTENT PREVIEW",
            "=" * 78,
        ]

        lines.append(f"First {len(r.content_preview)} rows of content:")
        lines.append("")

        for i, row in enumerate(r.content_preview, 1):
            row_str = " | ".join(cell[:20] for cell in row)
            lines.append(f"  Row {i}: [{row_str}]")
        lines.append("")

        lines.append("Cell Value Types:")
        total = sum(r.value_types.values())
        for vtype, count in r.value_types.most_common():
            pct = count / total * 100 if total > 0 else 0
            lines.append(f"  {vtype}: {count} ({pct:.1f}%)")
        lines.append("")

        if r.detected_patterns:
            lines.append("Detected Patterns:")
            for pattern in r.detected_patterns:
                lines.append(f"  - {pattern}")
        else:
            lines.append("Detected Patterns: None")
        lines.append("")

        return '\n'.join(lines)

    def format_visual_map(self, sheet: Worksheet) -> str:
        lines = [
            "=" * 78,
            "G. VISUAL STRUCTURE MAP",
            "=" * 78,
        ]

        mapper = VisualMapper()
        lines.append(mapper.generate_map(sheet))
        lines.append("")

        return '\n'.join(lines)

    def format_table_type(self) -> str:
        r = self.result
        lines = [
            "=" * 78,
            "H. TABLE TYPE DETECTION",
            "=" * 78,
            f"Most Likely: {r.likely_table_type}",
            f"Confidence: {r.table_type_confidence}",
            ""
        ]

        if r.table_type_evidence:
            lines.append("Evidence:")
            for ev in r.table_type_evidence:
                lines.append(f"  + {ev}")
        else:
            lines.append("Evidence: No distinctive patterns found")
        lines.append("")

        return '\n'.join(lines)

    def format_full_report(self, sheet: Worksheet, verbose: bool = False) -> str:
        """Generate the complete report."""
        sections = [
            self.format_header(),
            self.format_summary(),
            self.format_structure(),
            self.format_borders(),
            self.format_fonts(),
            self.format_alignment(),
            self.format_dimensions(),
            self.format_content(),
            self.format_visual_map(sheet),
            self.format_table_type(),
        ]

        return '\n'.join(sections)


# =============================================================================
# CLI
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Analyze Excel files generated by Stata commands (table1_tc, regtab, stratetab).",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python excel_analyzer.py output.xlsx
  python excel_analyzer.py output.xlsx --sheet "Table 1"
  python excel_analyzer.py output.xlsx --rows 15 --verbose

The tool analyzes:
  - Structure: rows, columns, merged cells
  - Borders: styles, patterns, locations
  - Fonts: families, sizes, bold/italic
  - Alignment: horizontal, vertical, text wrap
  - Dimensions: column widths, row heights
  - Content: preview, value types, patterns
  - Table type: detects table1_tc, regtab, or stratetab
"""
    )

    parser.add_argument(
        "file",
        help="Excel file to analyze (.xlsx)"
    )
    parser.add_argument(
        "--sheet", "-s",
        help="Sheet name to analyze (default: first/active sheet)"
    )
    parser.add_argument(
        "--rows", "-r",
        type=int,
        default=10,
        help="Number of rows to show in content preview (default: 10)"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Show more detailed output"
    )

    args = parser.parse_args()

    # Validate file exists
    if not Path(args.file).exists():
        print(f"Error: File not found: {args.file}", file=sys.stderr)
        sys.exit(1)

    # Validate file extension
    if not args.file.lower().endswith('.xlsx'):
        print("Warning: File does not have .xlsx extension. Attempting to read anyway.", file=sys.stderr)

    # Analyze
    analyzer = ExcelAnalyzer(args.file)
    if not analyzer.load(args.sheet):
        sys.exit(1)

    result = analyzer.analyze(preview_rows=args.rows)

    # Format and print report
    sheet_name = args.sheet or analyzer.workbook.active.title
    formatter = ReportFormatter(args.file, sheet_name, result)
    report = formatter.format_full_report(analyzer.sheet, verbose=args.verbose)

    print(report)


if __name__ == "__main__":
    main()
